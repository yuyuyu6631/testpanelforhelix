# 测试后台保活方案

## 问题描述
当前系统在测试运行时存在以下问题：
1. 前端页面刷新或切换窗口后，正在运行的测试会丢失
2. WebSocket 断开重连后无法恢复进度
3. 无法查询当前正在运行的批次

## 根本原因
- 测试运行状态只保存在内存中（`RUNNING_BATCHES` 字典）
- 缺少 API 提供正在运行的批次列表
- WebSocket 重连后没有恢复机制

## 解决方案

### 1. 后端改造

#### 1.1 添加查询正在运行批次的 API
```python
@router.get("/active-batches")
def get_active_batches(db: Session = Depends(get_db)):
    """获取所有正在运行的批次"""
    batches = db.query(TestBatch).filter(
        TestBatch.status == "RUNNING"
    ).order_by(TestBatch.start_time.desc()).all()
    
    return [{
        "batch_id": batch.id,
        "start_time": batch.start_time,
        "total_count": batch.total_count,
        "completed_count": db.query(TestHistory).filter(
            TestHistory.batch_id == batch.id
        ).count()
    } for batch in batches]
```

#### 1.2 WebSocket 重连恢复机制
在 WebSocket 连接时，自动发送当前批次的进度：
```python
@router.websocket("/ws/{batch_id}")
async def websocket_endpoint(websocket: WebSocket, batch_id: str, db: Session = Depends(get_db)):
    await manager.connect(batch_id, websocket)
    
    # 发送当前批次状态和已完成的测试结果
    batch = db.query(TestBatch).filter(TestBatch.id == batch_id).first()
    if batch:
        # 发送批次状态
        await websocket.send_text(json.dumps({
            "type": "batch_status",
            "status": batch.status,
            "total_count": batch.total_count,
            "pass_count": batch.pass_count
        }))
        
        # 发送已完成的测试结果
        completed_results = db.query(TestHistory, TestCase).join(
            TestCase, TestHistory.case_id == TestCase.id
        ).filter(TestHistory.batch_id == batch_id).all()
        
        for h, c in completed_results:
            await websocket.send_text(json.dumps({
                "type": "update",
                "case_id": h.case_id,
                "result": {
                    "case_id": h.case_id,
                    "question": h.question,
                    "actual_sql": h.actual_sql,
                    "expected_sql": c.expected_sql,
                    "result": h.result,
                    "message": h.error_message or "",
                    "duration": 0.0
                }
            }))
    
    try:
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        manager.disconnect(batch_id, websocket)
```

### 2. 前端改造

#### 2.1 页面加载时恢复运行中的批次
```typescript
useEffect(() => {
  // 检查是否有正在运行的批次
  fetch('/run/active-batches')
    .then(res => res.json())
    .then(batches => {
      if (batches.length > 0) {
        // 恢复最新的运行批次
        const latestBatch = batches[0];
        setBatchId(latestBatch.batch_id);
        connectWebSocket(latestBatch.batch_id);
      }
    });
}, []);
```

#### 2.2 WebSocket 自动重连
```typescript
function connectWebSocket(batchId: string) {
  const ws = new WebSocket(`ws://localhost:8000/run/ws/${batchId}`);
  
  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    // 处理各种消息类型
  };
  
  ws.onclose = () => {
    // 3秒后自动重连
    setTimeout(() => {
      if (isRunning) {
        connectWebSocket(batchId);
      }
    }, 3000);
  };
}
```

### 3. 数据库状态管理

确保 TestBatch 表正确记录运行状态：
- 创建批次时立即写入数据库（状态：RUNNING）
- 完成时更新状态为 COMPLETED
- 手动停止时更新状态为 STOPPED

## 实施步骤

1. ✅ 确认数据库模型正确（TestBatch 表已存在）
2. ✅ 修改 runner.py 添加 `/active-batches` 接口
3. ✅ 修改 WebSocket 端点支持状态恢复
4. ✅ 前端添加自动恢复逻辑
5. ✅ 前端添加 WebSocket 自动重连
6. ⏳ 测试完整流程

## 测试验证

1. 启动一个测试任务
2. 刷新页面，验证任务是否继续运行
3. 关闭 WebSocket 连接，验证是否自动重连
4. 验证重连后能否看到之前的测试结果
